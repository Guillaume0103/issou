<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Terre 3D (sans module)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js (ancien système non-modulaire) -->
  <script src="https://unpkg.com/three@0.110.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.110.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff);
    scene.add(light);

    const loader = new THREE.TextureLoader();
    const earthTexture = loader.load('textures/image.png');
    const image = new Image();
image.crossOrigin = "anonymous";  // pour éviter les problèmes CORS si besoin
image.src = 'textures/ma-terre-custom.png';  // remplace par le chemin de ta texture perso

const textureCanvas = document.createElement('canvas');
const ctx = textureCanvas.getContext('2d');

image.onload = () => {
  textureCanvas.width = image.width;
  textureCanvas.height = image.height;
  ctx.drawImage(image, 0, 0);
};


    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const material = new THREE.MeshPhongMaterial({ map: earthTexture });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    // Pour éviter l'affichage du menu contextuel classique
window.addEventListener('contextmenu', function (e) {
  e.preventDefault();
  function getColorAtUV(uv) {
  if (!textureCanvas.width || !textureCanvas.height) return null;

  const x = Math.floor(uv.x * textureCanvas.width);
  const y = Math.floor((1 - uv.y) * textureCanvas.height); // inversion de y dans la texture

  const pixel = ctx.getImageData(x, y, 1, 1).data;
  return { r: pixel[0], g: pixel[1], b: pixel[2], a: pixel[3] };
}

function couleurPresqueEgale(c1, c2, tol = 20) {
  return Math.abs(c1.r - c2.r) < tol &&
         Math.abs(c1.g - c2.g) < tol &&
         Math.abs(c1.b - c2.b) < tol;
}

const jaune = { r: 255, g: 255, b: 0 };
const bleu = { r: 0, g: 0, b: 255 };

  onRightClick(e);
});

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Fonction appelée au clic droit
function onRightClick(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(sphere);
  if (intersects.length > 0) {
    const intersect = intersects[0];
    const point = intersect.point;

    // Récupération des coordonnées UV
    const uv = intersect.uv;

    // Lire la couleur sur la texture
    const pixelColor = getColorAtUV(uv);
    let couleurPoint = 0xff0000; // rouge par défaut

    if (pixelColor) {
      if (couleurPresqueEgale(pixelColor, jaune)) {
        couleurPoint = 0xFFFF00; // jaune
      } else if (couleurPresqueEgale(pixelColor, bleu)) {
        couleurPoint = 0x0000FF; // bleu
      }
    }

    // Créer un petit point avec la couleur choisie
    const dotGeometry = new THREE.SphereGeometry(0.01, 16, 16);
    const dotMaterial = new THREE.MeshBasicMaterial({ color: couleurPoint });
    const dot = new THREE.Mesh(dotGeometry, dotMaterial);

    dot.position.copy(sphere.worldToLocal(point.clone()));
    sphere.add(dot);
  }
}

}

  </script>
</body>
</html>
