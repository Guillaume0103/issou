<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Tâches organiques sur sphère</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://unpkg.com/three@0.110.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 3);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff));

const sphere = new THREE.Mesh(
  new THREE.SphereGeometry(1, 64, 64),
  new THREE.MeshPhongMaterial({ color: 0x3366cc })
);
scene.add(sphere);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

const circles = []; // Chaque "tâche" sera un objet { mesh, geometry }

function onRightClick(event) {
  event.preventDefault();
  mouse.x = (event.clientX / innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObject(sphere);
  if (!hits.length) return;

  const hit = hits[0];
  const P = hit.point;
  const N = hit.face.normal.clone().transformDirection(sphere.matrixWorld);

  const segments = 64;
  const radius = 0.03;
  const geometry = new THREE.CircleGeometry(radius, segments);
  geometry.userData.originalPositions = geometry.attributes.position.array.slice();

  const material = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8
  });

  const mesh = new THREE.Mesh(geometry, material);

  const quaternion = new THREE.Quaternion().setFromUnitVectors(
    new THREE.Vector3(0, 0, 1), N
  );
  mesh.quaternion.copy(quaternion);

  sphere.add(mesh);
  const localPos = sphere.worldToLocal(P.clone().add(N.clone().multiplyScalar(0.001)));
  mesh.position.copy(localPos);

  circles.push({ mesh, geometry });
}
window.addEventListener('contextmenu', onRightClick);

function onLeftClick(event) {
  if (circles.length === 0) return;

  mouse.x = (event.clientX / innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObject(sphere);
  if (!hits.length) return;

  const hitPoint = hits[0].point;

  let closest = null;
  let minDist = Infinity;

  for (const c of circles) {
    const worldPos = new THREE.Vector3();
    c.mesh.getWorldPosition(worldPos);
    const dist = hitPoint.distanceTo(worldPos);
    if (dist < minDist) {
      minDist = dist;
      closest = c;
    }
  }

  if (!closest) return;

  const mesh = closest.mesh;
  const geom = closest.geometry;
  const original = geom.userData.originalPositions;

  const localClick = mesh.worldToLocal(hitPoint.clone());
  const dir2D = new THREE.Vector2(localClick.x, localClick.y).normalize();

  const pos = geom.attributes.position.array;
  for (let i = 0; i < pos.length; i += 3) {
    const x = original[i], y = original[i + 1];
    const angle = Math.atan2(y, x);
    const ptDir = new THREE.Vector2(Math.cos(angle), Math.sin(angle));

    const dot = ptDir.dot(dir2D);
    if (dot > 0.5) { // n'affecter que les sommets dans la même direction
      const scale = 1 + 0.3 * dot;
      pos[i] = x * scale;
      pos[i + 1] = y * scale;
    }
  }
  geom.attributes.position.needsUpdate = true;
}

window.addEventListener('click', onLeftClick);

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
