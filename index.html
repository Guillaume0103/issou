<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Sphère + Cercles Dynamiques</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.110.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.110.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // —— 1. Setup scène, caméra, rendu ——  
  const scene    = new THREE.Scene();
  const camera   = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,0,3);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // lumière  
  scene.add(new THREE.AmbientLight(0xffffff));

  // sphère  
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(1,64,64),
    new THREE.MeshPhongMaterial({color:0x3366cc})
  );
  scene.add(sphere);

  // contrôles  
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // raycaster & souris  
  const raycaster = new THREE.Raycaster();
  const mouse     = new THREE.Vector2();

  // liste de tous les cercles  
  const circles = [];

  // —— 2. Clic droit : ajouter un cercle ——
  function onRightClick(event) {
    event.preventDefault();
    mouse.x = (event.clientX / innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const hits = raycaster.intersectObject(sphere);
    if (!hits.length) return;

    const hit   = hits[0];
    const P     = hit.point;
    const N     = hit.face.normal.clone().transformDirection(sphere.matrixWorld);

    // géométrie cercle (plane)  
    const circleGeo = new THREE.CircleGeometry(0.03, 32);
    const circleMat = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.8
    });
    const circle = new THREE.Mesh(circleGeo, circleMat);

    // orientation : aligner plan sur normale  
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0,0,1), N
    );
    circle.quaternion.copy(quaternion);

    // rattacher à la sphère et position locale  
    sphere.add(circle);
    const localPos = sphere.worldToLocal(P.clone().add(N.clone().multiplyScalar(0.001)));
    circle.position.copy(localPos);

    circles.push(circle);
  }

  window.addEventListener('contextmenu', onRightClick);


  // —— 3. Clic gauche : étendre le cercle sous le pointeur ——
function onLeftClick(event) {
  if (circles.length === 0) return;

  mouse.x = (event.clientX / innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObject(sphere);
  if (!hits.length) return;

  const hitPoint = hits[0].point;

  // Trouver le cercle le plus proche du clic
  let closestCircle = null;
  let minDist = Infinity;

  for (const circle of circles) {
    const worldPos = new THREE.Vector3();
    circle.getWorldPosition(worldPos);
    const dist = hitPoint.distanceTo(worldPos);
    if (dist < minDist) {
      minDist = dist;
      closestCircle = circle;
    }
  }

  if (!closestCircle) return;

  // Transformer le point de clic dans le repère local du cercle
  const localPoint = closestCircle.worldToLocal(hitPoint.clone());
  const dir2D = new THREE.Vector2(localPoint.x, localPoint.y).normalize();

  // Étendre le cercle dans cette direction (tâche étirée)
  const factor = 0.3;
  closestCircle.scale.x += factor * dir2D.x;
  closestCircle.scale.y += factor * dir2D.y;
}


  window.addEventListener('click', onLeftClick);


  // —— 4. Boucle d’animation ——  
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // redimensionnement  
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  </script>
</body>
</html>
